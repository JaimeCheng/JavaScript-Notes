<div id="cnblogs_post_body">
	<ul>
		<li>
			<a href="#link01">数组求和</a>
		</li>
		<li>
			<a href="#link02">求数组的最大值和最小值</a>
		</li>
		<li>
			<a href="#link03">求数组的最大值和次大值</a>
		</li>
		<li>
			<a href="#link04">求数组中出现次数超过一半的元素</a>
		</li>
		<li>
			<a href="#link05">求数组中元素的最短距离</a>
		</li>
		<li>
			<a href="#link06">求两个有序数组的共同元素</a>
		</li>
		<li>
			<a href="#link07">求三个数组的共同元素</a>
		</li>
		<li>
			<a href="#link08">找出数组中唯一的重复元素</a>
		</li>
		<li>
			<a href="#link09">找出出现奇数次的元素</a>
		</li>
		<li>
			<a href="#link10">求数组中满足给定和的数对</a>
		</li>
		<li>
			<a href="#link11">最大子段和</a>
		</li>
		<li>
			<a href="#link12">最大子段积</a>
		</li>
		<li>
			<a href="#link13">数组循环移位</a>
		</li>
		<li>
			<a href="#link14">字符串逆序</a>
		</li>
		<li>
			<a href="#link15">组合问题</a>
		</li>
		<li>
			<a href="#link16">合并两个数组</a>
		</li>
		<li>
			<a href="#link17">重排问题</a>
		</li>
		<li>
			<a href="#link18">找出绝对值最小的元素</a>
		</li>
	</ul>
	<h1><a name="link01"></a>数组求和</h1>
	<p>给定一个含有n个元素的整型数组a，求a中所有元素的和。可能您会觉得很简单，是的，的确简单，但是为什么还要说呢，原因有二，第一，这道题要求用递归法，只用一行代码。第二，这是我人生中第一次面试时候遇到的题，意义特殊。</p>
	<h2>分析</h2>
	<p>简单说一下，两种情况</p>
	<p>1. 如果数组元素个数为0，那么和为0。</p>
	<p>2. 如果数组元素个数为n，那么先求出前n - 1个元素之和，再加上a[n - 1]即可</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div>
			<!--<br /><br />Code highlighting produced by Actipro CodeHighlighter (freeware)<br />http://www.CodeHighlighter.com/<br /><br />--><span style="color: #008000;">//</span><span style="color: #008000;"> 数组求和</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">int</span><span style="color: #000000;"> sum(</span><span style="color: #0000ff;">int</span><span style="color: #000000;">*</span><span style="color: #000000;">a, </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> n </span><span style="color: #000000;">==</span><span style="color: #800080;">0</span><span style="color: #000000;">?</span><span style="color: #800080;">0</span><span style="color: #000000;"> : sum(a, n </span><span style="color: #000000;">-</span><span style="color: #800080;">1</span><span style="color: #000000;">) </span><span style="color: #000000;">+</span><span style="color: #000000;"> a[n </span><span style="color: #000000;">-</span><span style="color: #800080;">1</span><span style="color: #000000;">];<br>}</span></div>

	</div>
	<h1><a name="link02"></a>求数组的最大值和最小值</h1>
	<p>给定一个含有n个元素的整型数组a，找出其中的最大值和最小值</p>
	<h2>分析</h2>
	<p>常规的做法是遍历一次，分别求出最大值和最小值，但我这里要说的是分治法(Divide and couquer)，将数组分成左右两部分，先求出左半部份的最大值和最小值，再求出右半部份的最大值和最小值，然后综合起来求总体的最大值及最小值。这是个递归过程，对于划分后的左右两部分，同样重复这个过程，直到划分区间内只剩一个元素或者两个元素。</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 求数组的最大值和最小值，返回值在maxValue和minValue</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">void</span> MaxandMin(<span style="color: #0000ff;">int</span> *a, <span style="color: #0000ff;">int</span> l, <span style="color: #0000ff;">int</span> r, <span style="color: #0000ff;">int</span>&amp; maxValue, <span style="color: #0000ff;">int</span>&amp; minValue)<br>{<br>    <span style="color: #0000ff;">if</span>(l == r) <span style="color: #008000;">//</span><span style="color: #008000;"> l与r之间只有一个元素</span><span style="color: #008000;"><br></span>    {<br>        maxValue = a[l] ;<br>        minValue = a[l] ;<br>        <span style="color: #0000ff;">return</span> ;<br>    }<br><br>    <span style="color: #0000ff;">if</span>(l + <span style="color: #800080;">1</span> == r) <span style="color: #008000;">//</span><span style="color: #008000;"> l与r之间只有两个元素</span><span style="color: #008000;"><br></span>    {<br>        <span style="color: #0000ff;">if</span>(a[l] &gt;= a[r])<br>        {<br>            maxValue = a[l] ;<br>            minValue = a[r] ;<br>        }<br>        <span style="color: #0000ff;">else</span><br>        {<br>            maxValue = a[r] ;<br>            minValue = a[l] ;<br>        }<br>        <span style="color: #0000ff;">return</span> ;<br>    }<br><br>    <span style="color: #0000ff;">int</span> m = (l + r) / <span style="color: #800080;">2</span> ; <span style="color: #008000;">//</span><span style="color: #008000;"> 求中点</span><span style="color: #008000;"><br></span><br>    <span style="color: #0000ff;">int</span> lmax ; <span style="color: #008000;">//</span><span style="color: #008000;"> 左半部份最大值</span><span style="color: #008000;"><br></span>    <span style="color: #0000ff;">int</span> lmin ; <span style="color: #008000;">//</span><span style="color: #008000;"> 左半部份最小值</span><span style="color: #008000;"><br></span>    MaxandMin(a, l, m, lmax, lmin) ; <span style="color: #008000;">//</span><span style="color: #008000;"> 递归计算左半部份</span><span style="color: #008000;"><br></span><br>    <span style="color: #0000ff;">int</span> rmax ; <span style="color: #008000;">//</span><span style="color: #008000;"> 右半部份最大值</span><span style="color: #008000;"><br></span>    <span style="color: #0000ff;">int</span> rmin ; <span style="color: #008000;">//</span><span style="color: #008000;"> 右半部份最小值</span><span style="color: #008000;"><br></span>    MaxandMin(a, m + <span style="color: #800080;">1</span>, r, rmax, rmin) ; <span style="color: #008000;">//</span><span style="color: #008000;"> 递归计算右半部份</span><span style="color: #008000;"><br></span><br>    maxValue = max(lmax, rmax) ; <span style="color: #008000;">//</span><span style="color: #008000;"> 总的最大值</span><span style="color: #008000;"><br></span>    minValue = min(lmin, rmin) ; <span style="color: #008000;">//</span><span style="color: #008000;"> 总的最小值</span><span style="color: #008000;"><br></span>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<h1><a name="link03"></a>求数组的最大值和次大值</h1>
	<p>给定一个含有n个元素的整型数组，求其最大值和次大值</p>
	<h2>分析</h2>
	<p>思想和上一题类似，同样是用分治法，先求出左边的最大值leftmax和次大值leftsecond，再求出右边的最大值rightmax和次大值rightsecond，然后合并，如何合并呢？分情况考虑</p>
	<p>1 如果leftmax &gt; rightmax，那么可以肯定leftmax是最大值，但次大值不一定是rightmax，但肯定不是rightsecond，只需将leftsecond与rightmax做一次比较即可。</p>
	<p>2 如果rightmax &gt; leftmax，那么可以肯定rightmax是最大值，但次大值不一定是leftmax，但肯定不是leftsecond，所以只需将leftmax与rightsecond做一次比较即可。</p>
	<h2>注意</h2>
	<p>这种方法无法处理最大元素有多个的情况，比如3,5,7,7将返回7，7而不是7,5。感谢网友 从无到有靠谁人 指出。</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 找出数组的最大值和次大值，a是待查找的数组，left和right是查找区间，max和second存放结果</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">void</span><span style="color: #000000;"> MaxandMin(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a[], </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> left, </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> right, </span><span style="color: #0000ff;">int</span><span style="color: #000000;">&amp;</span><span style="color: #000000;">max, </span><span style="color: #0000ff;">int</span><span style="color: #000000;">&amp;</span><span style="color: #000000;">second)<br>{<br>    </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(left </span><span style="color: #000000;">==</span><span style="color: #000000;"> right)<br>    {<br>        max </span><span style="color: #000000;">=</span><span style="color: #000000;"> a[left] ;<br>        second </span><span style="color: #000000;">=</span><span style="color: #000000;">&nbsp; INT_MIN;<br>    }<br>    </span><span style="color: #0000ff;">else</span><span style="color: #0000ff;">if</span><span style="color: #000000;">(left </span><span style="color: #000000;">+</span><span style="color: #800080;">1</span><span style="color: #000000;">==</span><span style="color: #000000;"> right)<br>    {<br>        max </span><span style="color: #000000;">=</span><span style="color: #000000;"> a[left] </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> a[right] </span><span style="color: #000000;">?</span><span style="color: #000000;"> a[left] : a[right] ;<br>        second </span><span style="color: #000000;">=</span><span style="color: #000000;"> a[left] </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> a[right] </span><span style="color: #000000;">?</span><span style="color: #000000;"> a[left] : a[right] ;<br>    }<br>    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"><br>    {<br>        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> mid </span><span style="color: #000000;">=</span><span style="color: #000000;"> left </span><span style="color: #000000;">+</span><span style="color: #000000;"> (right </span><span style="color: #000000;">-</span><span style="color: #000000;"> left) </span><span style="color: #000000;">/</span><span style="color: #800080;">2</span><span style="color: #000000;"> ;<br><br>        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> leftmax ;<br>        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> leftsecond ;<br>        MaxandMin(a, left, mid, leftmax, leftsecond) ;<br><br>        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> rightmax ;<br>        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> rightsecond ;<br>        MaxandMin(a, mid </span><span style="color: #000000;">+</span><span style="color: #800080;">1</span><span style="color: #000000;">, right, rightmax, rightsecond) ;<br><br>        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (leftmax </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> rightmax)<br>        {<br>            max </span><span style="color: #000000;">=</span><span style="color: #000000;"> leftmax ;<br>            second </span><span style="color: #000000;">=</span><span style="color: #000000;"> leftsecond </span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> rightmax </span><span style="color: #000000;">?</span><span style="color: #000000;"> leftsecond : rightmax ;<br>        }<br>        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"><br>        {<br>            max </span><span style="color: #000000;">=</span><span style="color: #000000;"> rightmax ;<br>            second </span><span style="color: #000000;">=</span><span style="color: #000000;"> leftmax </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> rightsecond </span><span style="color: #000000;">?</span><span style="color: #000000;"> rightsecond : leftmax ;<br>        }<br>    }<br>}</span></pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<h1><a name="link04"></a>求数组中出现次数超过一半的元素</h1>
	<p>给定一个n个整型元素的数组a，其中有一个元素出现次数超过n / 2，求这个元素。据说是百度的一道题</p>
	<h2>分析</h2>
	<p>设置一个当前值和当前值的计数器，初始化当前值为数组首元素，计数器值为1，然后从第二个元素开始遍历整个数组，对于每个被遍历到的值a[i]</p>
	<p>1 如果a[i]==currentValue，则计数器值加1</p>
	<p>2 如果a[i] != currentValue， 则计数器值减1，如果计数器值小于0，则更新当前值为a[i]，并将计数器值重置为1</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 找出数组中出现次数超过一半的元素</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">int</span> Find(<span style="color: #0000ff;">int</span>* a, <span style="color: #0000ff;">int</span> n)<br>{<br>    <span style="color: #0000ff;">int</span> curValue = a[<span style="color: #800080;">0</span>] ;<br>    <span style="color: #0000ff;">int</span> count = <span style="color: #800080;">1</span> ;<br><br>    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++i)<br>    {<br>        <span style="color: #0000ff;">if</span> (a[i] == curValue)<br>            count++ ;<br>        <span style="color: #0000ff;">else</span><br>        {<br>            count-- ;<br>            <span style="color: #0000ff;">if</span> (count &lt; <span style="color: #800080;">0</span>)<br>            {<br>                curValue = a[i] ;<br>                count = <span style="color: #800080;">1</span> ;<br>            }<br>        }<br>    }<br><br>    <span style="color: #0000ff;">return</span> curValue ;<br>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<p>另一个方法是先对数组排序，然后取中间元素即可，因为如果某个元素的个数超过一半，那么数组排序后该元素必定占据数组的中间位置。</p>
	<h1><a name="link05"></a>求数组中元素的最短距离</h1>
	<p>给定一个含有n个元素的整型数组，找出数组中的两个元素x和y使得abs(x - y)值最小</p>
	<h2>分析</h2>
	<p>先对数组排序，然后遍历一次即可</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #0000ff;">int</span> compare(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span>* a, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span>* b)<br>{<br>    <span style="color: #0000ff;">return</span> *(<span style="color: #0000ff;">int</span>*)a - *(<span style="color: #0000ff;">int</span>*)b ;<br>}<br><br><span style="color: #008000;">//</span><span style="color: #008000;"> 求数组中元素的最短距离</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">void</span> MinimumDistance(<span style="color: #0000ff;">int</span>* a, <span style="color: #0000ff;">int</span> n)<br>{<br>    <span style="color: #008000;">//</span><span style="color: #008000;"> Sort</span><span style="color: #008000;"><br></span>    qsort(a, n, <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>), compare) ;<br><br>    <span style="color: #0000ff;">int</span> i ; <span style="color: #008000;">//</span><span style="color: #008000;"> Index of number 1</span><span style="color: #008000;"><br></span>    <span style="color: #0000ff;">int</span> j ; <span style="color: #008000;">//</span><span style="color: #008000;"> Index of number 2</span><span style="color: #008000;"><br></span><br>    <span style="color: #0000ff;">int</span> minDistance = numeric_limits&lt;<span style="color: #0000ff;">int</span>&gt;::max() ;<br>    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; n - <span style="color: #800080;">1</span>; ++k)<br>    {<br>        <span style="color: #0000ff;">if</span> (a[k + <span style="color: #800080;">1</span>] - a[k] &lt; minDistance)<br>        {<br>            minDistance = a[k + <span style="color: #800080;">1</span>] - a[k] ;<br>            i = a[k] ;<br>            j = a[k + <span style="color: #800080;">1</span>] ;<br>        }<br>    }<br><br>    cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Minimum distance is: </span><span style="color: #800000;">"</span> &lt;&lt; minDistance &lt;&lt; endl ;<br>    cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">i = </span><span style="color: #800000;">"</span> &lt;&lt; i &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;"> j = </span><span style="color: #800000;">"</span> &lt;&lt; j &lt;&lt; endl ;<br>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<h1><a name="link06"></a>求两个有序数组的共同元素</h1>
	<p>给定两个含有n个元素的有序（非降序）整型数组a和b，求出其共同元素，比如</p>
	<p>a = 0, 1, 2, 3, 4</p>
	<p>b = 1, 3, 5, 7, 9</p>
	<p>输出 1, 3</p>
	<h2>分析</h2>
	<p>充分利用数组有序的性质，用两个指针i和j分别指向a和b，比较a[i]和b[j]，根据比较结果移动指针，则有如下三种情况</p>
	<p>1. a[i] &lt; b[j]，则i增加1，继续比较</p>
	<p>2. a[i] == b[j]，则i和j皆加1，继续比较</p>
	<p>3. a[i] &lt; b[j]，则j加1，继续比较</p>
	<p>重复以上过程直到i或j到达数组末尾。</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 找出两个数组的共同元素</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">void</span> FindCommon(<span style="color: #0000ff;">int</span>* a, <span style="color: #0000ff;">int</span>* b, <span style="color: #0000ff;">int</span> n)<br>{<br>    <span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>;<br>    <span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span> ;<br><br>    <span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; j &lt; n)<br>    {<br>        <span style="color: #0000ff;">if</span> (a[i] &lt; b[j])<br>            ++i ;<br>        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(a[i] == b[j])<br>        {<br>            cout &lt;&lt; a[i] &lt;&lt; endl ;<br>            ++i ;<br>            ++j ;<br>        }<br>        <span style="color: #0000ff;">else</span><span style="color: #008000;">//</span><span style="color: #008000;"> a[i] &gt; b[j]</span><span style="color: #008000;"><br></span>            ++j ;<br>    }<br>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<p>这到题还有其他的解法，比如对于a中任意一个元素，在b中对其进行Binary Search，因为a中有n个元素，而在b中进行Binary Search需要logn。所以找出全部相同元素的时间复杂度是O(nlogn)。</p>
	<p>另外，上面的方法，只要b有序即可，a是否有序无所谓，因为我们只是在b中做Binary Search。如果a也有序的话，那么再用上面的方法就有点慢了，因为如果a中某个元素在b中的位置是k的话，那么a中下一个元素在b中的位置一定位于k的右侧，所以本次的搜索空间可以根据上次的搜索结果缩小，而不是仍然在整个b中搜索。也即如果a和b都有序的话，代码可以做如下修改，记录上次搜索时b中元素的位置，作为下一次搜索的起始点。</p>
	<h1><a name="link07"></a>求三个数组的共同元素</h1>
	<p>给定三个含有n个元素的整型数组a,b和c，求他们最小的共同元素。</p>
	<h2>分析</h2>
	<p>如果三个数组都有序，那么可以设置三个指针指向三个数组的头部，然后根据这三个指针所指的值进行比较来移动指针，直道找到共同元素。</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 三个数组的共同元素-只找最小的</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">void</span> FindCommonElements(<span style="color: #0000ff;">int</span> a[], <span style="color: #0000ff;">int</span> b[], <span style="color: #0000ff;">int</span> c[], <span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span> y, <span style="color: #0000ff;">int</span> z)<br>{<br>    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>, k = <span style="color: #800080;">0</span>; i &lt; x &amp;&amp; j &lt; y &amp;&amp; k &lt; z;)<br>    {<br>        <span style="color: #0000ff;">if</span>(a[i] &lt; b[j])<br>        {<br>            i++ ;<br>        }<br>        <span style="color: #0000ff;">else</span> <span style="color: #008000;">//</span><span style="color: #008000;"> a[i] &gt;= b[j]</span><span style="color: #008000;"><br></span>        {<br>            <span style="color: #0000ff;">if</span>(b[j] &lt; c[k])<br>            {<br>                j++ ;<br>            }<br>            <span style="color: #0000ff;">else</span> <span style="color: #008000;">//</span><span style="color: #008000;"> b[j] &gt;= c[k]</span><span style="color: #008000;"><br></span>            {<br>                <span style="color: #0000ff;">if</span>(c[k] &lt; a[i])<br>                {<br>                    k++ ;<br>                }<br>                <span style="color: #0000ff;">else</span> <span style="color: #008000;">//</span><span style="color: #008000;"> c[k] &gt;= a[i]</span><span style="color: #008000;"><br></span>                {<br>                    cout &lt;&lt; c[k] &lt;&lt; endl ;<br>                    <span style="color: #0000ff;">return</span> ;<br>                }<br>            }<br>        }<br>    }<br><br>    cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Not found!</span><span style="color: #800000;">"</span> &lt;&lt; endl ;<br>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<p>如果三个数组都无序，可以先对a, b进行排序，然后对c中任意一个元素都在b和c中做二分搜索。</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 找出三个数组的共同元素<br></span><span style="color: #008000;">//</span><span style="color: #008000;"> O(NlogN)</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">int</span> UniqueCommonItem(<span style="color: #0000ff;">int</span> *a, <span style="color: #0000ff;">int</span> *b, <span style="color: #0000ff;">int</span> *c, <span style="color: #0000ff;">int</span> n)<br>{<br>    <span style="color: #008000;">//</span><span style="color: #008000;"> sort array a</span><span style="color: #008000;"><br></span>    qsort(a, n, <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>), compare) ; <span style="color: #008000;">//</span><span style="color: #008000;"> NlogN<br><br>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> sort array b</span><span style="color: #008000;"><br></span>    qsort(b, n, <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>), compare) ; <span style="color: #008000;">//</span><span style="color: #008000;"> NlogN<br><br>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> for each element in array c, do a binary search in a and b<br>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> This is up to a complexity of N*2*logN</span><span style="color: #008000;"><br></span>    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i++)<br>    {<br>        <span style="color: #0000ff;">if</span>(BinarySearch(a, n, c[i]) &amp;&amp; BinarySearch(b, n, c[i]))<br>            <span style="color: #0000ff;">return</span> c[i] ;<br>    }<br><br>    <span style="color: #0000ff;">return</span> - <span style="color: #800080;">1</span> ; <span style="color: #008000;">//</span><span style="color: #008000;"> not found</span><span style="color: #008000;"><br></span>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<p>也可以对a进行排序，然后对于b和c中任意一个元素都在a中进行二分搜索，但是这样做是有问题的，你看出来了么？感谢网友
		<a id="a_comment_author_2660466" href="http://home.cnblogs.com/u/518392/" target="_blank">yy_5533</a>指正。</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 找出三个数组唯一的共同元素<br></span><span style="color: #008000;">//</span><span style="color: #008000;"> O(NlogN)</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">int</span> UniqueCommonItem1(<span style="color: #0000ff;">int</span> *a, <span style="color: #0000ff;">int</span> *b, <span style="color: #0000ff;">int</span> *c, <span style="color: #0000ff;">int</span> n)<br>{<br>    <span style="color: #008000;">//</span><span style="color: #008000;"> sort array a</span><span style="color: #008000;"><br></span>    qsort(a, n, <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>), compare) ; <span style="color: #008000;">//</span><span style="color: #008000;"> NlogN<br><br>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Space for time</span><span style="color: #008000;"><br></span>    <span style="color: #0000ff;">bool</span> *bb = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">bool</span>[n] ;<br>    memset(bb, <span style="color: #800080;">0</span>, n) ;<br><br>    <span style="color: #0000ff;">bool</span> *bc = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">bool</span>[n] ;<br>    memset(bb, <span style="color: #800080;">0</span>, n) ;<br><br>    <span style="color: #008000;">//</span><span style="color: #008000;"> for each element in b, do a BS in a and mark all the common element</span><span style="color: #008000;"><br></span>    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i++) <span style="color: #008000;">//</span><span style="color: #008000;"> NlogN</span><span style="color: #008000;"><br></span>    {<br>        <span style="color: #0000ff;">if</span>(BinarySearch(a, n, b[i]))<br>            bb[i] = <span style="color: #0000ff;">true</span> ;<br>    }<br><br>    <span style="color: #008000;">//</span><span style="color: #008000;"> for each element in c, do a BS only if b[i] is true</span><span style="color: #008000;"><br></span>    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i++) <span style="color: #008000;">//</span><span style="color: #008000;"> NlogN</span><span style="color: #008000;"><br></span>    {<br>        <span style="color: #0000ff;">if</span>(b[i] &amp;&amp; BinarySearch(a, n, c[i]))<br>            <span style="color: #0000ff;">return</span> c[i] ;<br>    }<br><br>    <span style="color: #0000ff;">return</span> - <span style="color: #800080;">1</span> ; <span style="color: #008000;">//</span><span style="color: #008000;"> not found</span><span style="color: #008000;"><br></span>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<p>排序和二分搜索代码如下</p>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Determine whether a contains value k</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">bool</span> BinarySearch(<span style="color: #0000ff;">int</span> *a, <span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span> k)<br>{<br>    <span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span> ;<br>    <span style="color: #0000ff;">int</span> right = n - <span style="color: #800080;">1</span> ;<br>    <span style="color: #0000ff;">while</span> (left &lt;= right)<br>    {<br>        <span style="color: #0000ff;">int</span> mid = (left + right) ;<br><br>        <span style="color: #0000ff;">if</span>(a[mid] &lt; k)<br>            left = mid + <span style="color: #800080;">1</span> ;<br>        <span style="color: #0000ff;">if</span>(a[mid] == k)<br>            <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span> ;<br>        <span style="color: #0000ff;">else</span><br>            right = mid - <span style="color: #800080;">1</span> ;<br>    }<br><br>    <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span> ;<br>}<br><br><span style="color: #008000;">//</span><span style="color: #008000;"> Compare function for qsort</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">int</span> compare(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span>* a, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span>* b)<br>{<br>    <span style="color: #0000ff;">return</span> *(<span style="color: #0000ff;">int</span>*)a - *(<span style="color: #0000ff;">int</span>*)b ;<br>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<p>小小总结一下，对于在数组中进行查找的问题，可以分如下两种情况处理</p>
	<p>1. 如果给定的数组有序，那么首先应该想到Binary Search，所需O(logn)</p>
	<p>2. 如果给定的数组无序，那么首先应该想到对数组进行排序，很多排序算法都能在O(nlogn)时间内对数组进行排序，然后再使用二分搜索，总的时间复杂度仍是O(nlogn)。</p>
	<p>如果能做到以上两点，大多数关于数组的查找问题，都能迎刃而解。</p>
	<h1><a name="link08"></a>找出数组中唯一的重复元素</h1>
	<p>给定含有1001个元素的数组，其中存放了1-1000之内的整数，只有一个整数是重复的，请找出这个数</p>
	<h2>分析</h2>
	<p>求出整个数组的和，再减去1-1000的和</p>
	<h2>代码</h2>
	<p>略</p>
	<h1><a name="link09"></a>找出出现奇数次的元素</h1>
	<p>给定一个含有n个元素的整型数组a，其中只有一个元素出现奇数次，找出这个元素。这道题实际上是一个变种，原题是找出数组中唯一一个出现一次的元素，下面的方法可以同时解决这两道提。所以题目就用这个广义的吧。</p>
	<h2>分析</h2>
	<p>因为对于任意一个数k，有k ^ k = 0，k ^ 0 = k，所以将a中所有元素进行异或，那么个数为偶数的元素异或后都变成了0，只留下了个数为奇数的那个元素。</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<div>
			<!--</p><p>Code highlighting produced by Actipro CodeHighlighter (freeware)<br />http://www.CodeHighlighter.com/</p><p>--><span style="color: #0000ff;">int</span><span style="color: #000000;"> FindElementWithOddCount(</span><span style="color: #0000ff;">int</span><span style="color: #000000;">*</span><span style="color: #000000;">a, </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> r </span><span style="color: #000000;">=</span><span style="color: #000000;"> a[</span><span style="color: #800080;">0</span><span style="color: #000000;">] ;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #800080;">1</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> n; </span><span style="color: #000000;">++</span><span style="color: #000000;">i)<br>&nbsp;&nbsp;&nbsp;&nbsp;    {<br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;       r </span><span style="color: #000000;">^=</span><span style="color: #000000;"> a[i] ;<br>&nbsp;&nbsp;&nbsp;&nbsp;    }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> r ;<br>}</span></div>

		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<h1><a name="link10"></a>求数组中满足给定和的数对</h1>
	<p>给定两个有序整型数组a和b，各有n个元素，求两个数组中满足给定和的数对，即对a中元素i和b中元素j，满足i + j = d(d已知)</p>
	<h2>分析</h2>
	<p>两个指针i和j分别指向数组的首尾，然后从两端同时向中间遍历，直到两个指针交叉。</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 找出满足给定和的数对</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">void</span> FixedSum(<span style="color: #0000ff;">int</span>* a, <span style="color: #0000ff;">int</span>* b, <span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span> d)<br>{<br>    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = n - <span style="color: #800080;">1</span>; i &lt; n &amp;&amp; j &gt;= <span style="color: #800080;">0</span>)<br>    {<br>        <span style="color: #0000ff;">if</span> (a[i] + b[j] &lt; d)<br>            ++i ;<br>        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (a[i] + b[j] == d)<br>        {<br>            cout &lt;&lt; a[i] &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">, </span><span style="color: #800000;">"</span> &lt;&lt; b[j] &lt;&lt; endl ;<br>            ++i ;<br>            --j ;<br>        }<br>        <span style="color: #0000ff;">else</span> <span style="color: #008000;">//</span><span style="color: #008000;"> a[i] + b[j] &gt; d</span><span style="color: #008000;"><br></span>            --j ;<br>    }<br>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<h1><a name="link11"></a>最大子段和</h1>
	<p>给定一个整型数组a，求出最大连续子段之和，如果和为负数，则按0计算，比如1， 2， -5， 6， 8则输出6 + 8 = 14</p>
	<h2>分析</h2>
	<p>编程珠玑上的经典题目，不多说了。</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 子数组的最大和</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">int</span> Sum(<span style="color: #0000ff;">int</span>* a, <span style="color: #0000ff;">int</span> n)<br>{<br>    <span style="color: #0000ff;">int</span> curSum = <span style="color: #800080;">0</span>;<br>    <span style="color: #0000ff;">int</span> maxSum = <span style="color: #800080;">0</span>;<br>    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i++)<br>    {<br>        <span style="color: #0000ff;">if</span> (curSum + a[i] &lt; <span style="color: #800080;">0</span>)<br>            curSum = <span style="color: #800080;">0</span>;<br>        <span style="color: #0000ff;">else</span><br>        {<br>            curSum += a[i] ;<br>            maxSum = max(maxSum, curSum);<br>        }<br>    }<br>    <span style="color: #0000ff;">return</span> maxSum;<br>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<h1><a name="link12"></a>最大子段积</h1>
	<p>给定一个整型数组a，求出最大连续子段的乘积，比如 1， 2， -8， 12， 7则输出12 * 7 = 84</p>
	<h2>分析</h2>
	<p>与最大子段和类似，注意处理负数的情况</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 子数组的最大乘积</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">int</span> MaxProduct(<span style="color: #0000ff;">int</span> *a, <span style="color: #0000ff;">int</span> n)<br>{<br>    <span style="color: #0000ff;">int</span> maxProduct = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> max positive product at current position</span><span style="color: #008000;"><br></span>    <span style="color: #0000ff;">int</span> minProduct = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> min negative product at current position</span><span style="color: #008000;"><br></span>    <span style="color: #0000ff;">int</span> r = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> result, max multiplication totally</span><span style="color: #008000;"><br></span><br>    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i++)<br>    {<br>        <span style="color: #0000ff;">if</span> (a[i] &gt; <span style="color: #800080;">0</span>)<br>        {<br>            maxProduct *= a[i];<br>            minProduct = min(minProduct * a[i], <span style="color: #800080;">1</span>);<br>        }<br>        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (a[i] == <span style="color: #800080;">0</span>)<br>        {<br>            maxProduct = <span style="color: #800080;">1</span>;<br>            minProduct = <span style="color: #800080;">1</span>;<br>        }<br>        <span style="color: #0000ff;">else</span> <span style="color: #008000;">//</span><span style="color: #008000;"> a[i] &lt; 0</span><span style="color: #008000;"><br></span>        {<br>            <span style="color: #0000ff;">int</span> temp = maxProduct;<br>            maxProduct = max(minProduct * a[i], <span style="color: #800080;">1</span>);<br>            minProduct = temp * a[i];<br>        }<br><br>        r = max(r, maxProduct);<br>    }<br><br>    <span style="color: #0000ff;">return</span> r;<br>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<h1><a name="link13"></a>数组循环移位</h1>
	<p>将一个含有n个元素的数组向右循环移动k位，要求时间复杂度是O(n)，且只能使用两个额外的变量，这是在微软的编程之美上看到的一道题</p>
	<h2>分析</h2>
	<p>比如数组 1 2 3 4循环右移1位 将变成 4 1 2 3， 观察可知1 2 3 的顺序在移位前后没有改变，只是和4的位置交换了一下，所以等同于1 2 3 4 先划分为两部分 &nbsp;</p>
	<p>1 2 3 | 4，然后将1 2 3逆序，再将4 逆序 得到 3 2 1 4，最后整体逆序&nbsp;得到 4 1 2 3</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 将buffer中start和end之间的元素逆序</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">void</span> Reverse( <span style="color: #0000ff;">int</span> buffer[], <span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span> end )<br>{<br>    <span style="color: #0000ff;">while</span> ( start &lt; end )<br>    {<br>        <span style="color: #0000ff;">int</span> temp = buffer[ start ] ;<br>        buffer[ start++ ] = buffer[ end ] ;<br>        buffer[ end-- ] = temp ;<br>    }<br>}<br><br><span style="color: #008000;">//</span><span style="color: #008000;"> 将含有n个元素的数组buffer右移k位</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">void</span> Shift( <span style="color: #0000ff;">int</span> buffer[], <span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span> k )<br>{<br>    k %= n ;<br><br>    Reverse( buffer, <span style="color: #800080;">0</span>, n - k - <span style="color: #800080;">1</span>) ;<br>    Reverse( buffer, n - k, n - <span style="color: #800080;">1</span> ) ;<br>    Reverse( buffer, <span style="color: #800080;">0</span>, n - <span style="color: #800080;">1</span> ) ;<br>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<p>稍微扩展一下,如果允许分配额外的数组,那么定义一个新的数组,然后将移位后的元素直接存入即可,也可以使用队列,将移动后得元素出对,再插入队尾即可.</p>
	<h1><a name="link14"></a>字符串逆序</h1>
	<p>给定一个含有n个元素的字符数组a，将其原地逆序。</p>
	<h2>分析</h2>
	<p>可能您觉得这不是关于数组的，而是关于字符串的。是的。但是别忘了题目要求的是原地逆序，也就是不允许额外分配空间，那么参数肯定是字符数组形式，因为字符串是不能被修改的（这里只C/C++中的字符串常量），所以，和数组有关了吧，只不过不是整型数组，而是字符数组。用两个指针分别指向字符数组的首位，交换其对应的字符，然后两个指针分别向数组中央移动，直到交叉。</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<div>
			<!--<br /><br />Code highlighting produced by Actipro CodeHighlighter (freeware)<br />http://www.CodeHighlighter.com/<br /><br />--><span style="color: #008000;">//</span><span style="color: #008000;"> 字符串逆序</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">void</span><span style="color: #000000;"> Reverse(</span><span style="color: #0000ff;">char</span><span style="color: #000000;">*</span><span style="color: #000000;">a, </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> left </span><span style="color: #000000;">=</span><span style="color: #800080;">0</span><span style="color: #000000;">; <br>&nbsp;&nbsp;&nbsp;&nbsp;    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> right </span><span style="color: #000000;">=</span><span style="color: #000000;"> n </span><span style="color: #000000;">-</span><span style="color: #800080;">1</span><span style="color: #000000;">;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;    </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (left </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> right)<br>&nbsp;&nbsp;&nbsp;&nbsp;    {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> temp </span><span style="color: #000000;">=</span><span style="color: #000000;"> a[left] ;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        a[left</span><span style="color: #000000;">++</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> a[right] ;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        a[right</span><span style="color: #000000;">--</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> temp ;<br>&nbsp;&nbsp;&nbsp;&nbsp;    }<br>}</span></div>

		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<h1><a name="link15"></a>组合问题</h1>
	<p>给定一个含有n个元素的整型数组a，从中任取m个元素，求所有组合。比如下面的例子</p>
	<p>a = 1, 2, 3, 4, 5</p>
	<p>m = 3</p>
	<p>输出</p>
	<p>1 2 3, 1 2 4, 1 2 5, 1 3 4, 1 3 5, 1 4 5</p>
	<p>2 3 4, 2 3 5, 2 4 5<br>3 4 5</p>
	<h2>分析</h2>
	<p>典型的排列组合问题，首选回溯法，为了简化问题，我们将a中n个元素值分别设置为1-n</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> n选m的所有组合</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">int</span> buffer[<span style="color: #800080;">100</span>] ;<br><br><span style="color: #0000ff;">void</span> PrintArray(<span style="color: #0000ff;">int</span> *a, <span style="color: #0000ff;">int</span> n)<br>{<br>    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i)<br>        cout &lt;&lt; a[i] &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">"</span>;<br>    cout &lt;&lt; endl ;<br>}<br><br><span style="color: #0000ff;">bool</span> IsValid(<span style="color: #0000ff;">int</span> lastIndex, <span style="color: #0000ff;">int</span> value)<br>{<br>    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; lastIndex; i++)<br>    {<br>        <span style="color: #0000ff;">if</span> (buffer[i] &gt;= value)<br>            <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>;<br>    }<br>    <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;<br>}<br><br><span style="color: #0000ff;">void</span> Select(<span style="color: #0000ff;">int</span> t, <span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span> m)<br>{<br>    <span style="color: #0000ff;">if</span> (t == m)<br>        PrintArray(buffer, m);<br>    <span style="color: #0000ff;">else</span><br>    {<br>        <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n; i++)<br>        {<br>            buffer[t] = i;<br>            <span style="color: #0000ff;">if</span> (IsValid(t, i))<br>                Select(t + <span style="color: #800080;">1</span>, n, m);<br>        }<br>    }<br>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<h1><a name="link16"></a>合并两个数组</h1>
	<p>给定含有n个元素的两个有序（非降序）整型数组a和b。合并两个数组中的元素到整型数组c，要求去除重复元素并保持c有序（非降序）。例子如下</p>
	<p>a = 1, 2, 4, 8</p>
	<p>b = 1, 3, 5, 8</p>
	<p>c = 1, 2, 3, 4, 5, 8</p>
	<h2>分析</h2>
	<p>利用合并排序的思想，两个指针i,j和k分别指向数组a和b，然后比较两个指针对应元素的大小，有以下三种情况</p>
	<p>1. a[i] &lt; b[j]，则c[k] = a[i]。</p>
	<p>2. a[i] == b[j]，则c[k]等于a[i]或b[j]皆可。</p>
	<p>3. a[i] &gt; b[j]，则c[k] = b[j]。</p>
	<p>重复以上过程，直到i或者j到达数组末尾，然后将剩下的元素直接copy到数组c中即可</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 合并两个有序数组</span><span style="color: #008000;"><br></span><span style="color: #0000ff;">void</span> Merge(<span style="color: #0000ff;">int</span> *a, <span style="color: #0000ff;">int</span> *b, <span style="color: #0000ff;">int</span> *c, <span style="color: #0000ff;">int</span> n)<br>{<br>    <span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span> ;<br>    <span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span> ;<br>    <span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span> ;<br><br>    <span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; j &lt; n)<br>    {<br>        <span style="color: #0000ff;">if</span> (a[i] &lt; b[j])<span style="color: #008000;">//</span><span style="color: #008000;"> 如果a的元素小，则插入a中元素到c</span><span style="color: #008000;"><br></span>        {<br>            c[k++] = a[i] ;<br>            ++i ;<br>        }<br>        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (a[i] == b[j])<span style="color: #008000;">//</span><span style="color: #008000;"> 如果a和b元素相等，则插入二者皆可，这里插入a</span><span style="color: #008000;"><br></span>        {<br>            c[k++] = a[i] ;<br>            ++i ;<br>            ++j ;<br>        }<br>        <span style="color: #0000ff;">else</span> <span style="color: #008000;">//</span><span style="color: #008000;"> a[i] &gt; b[j] </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果b中元素小，则插入b中元素到c</span><span style="color: #008000;"><br></span>        {<br>            c[k++] = b[j] ;<br>            ++j ;<br>        }<br>    }<br><br>    <span style="color: #0000ff;">if</span> (i == n) <span style="color: #008000;">//</span><span style="color: #008000;"> 若a遍历完毕，处理b中剩下的元素</span><span style="color: #008000;"><br></span>    {<br>        <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> m = j; m &lt; n; ++m)<br>            c[k++] = b[m] ;<br>    }<br>    <span style="color: #0000ff;">else</span><span style="color: #008000;">//</span><span style="color: #008000;">j == n, 若b遍历完毕，处理a中剩下的元素</span><span style="color: #008000;"><br></span>    {<br>        <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> m = i; m &lt; n; ++m)<br>            c[k++] = a[m] ;<br>    }<br>}</pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<h1><a name="link17"></a>重排问题</h1>
	<p>给定含有n个元素的整型数组a，其中包括0元素和非0元素，对数组进行排序，要求：</p>
	<p>1. 排序后所有0元素在前，所有非零元素在后，且非零元素排序前后相对位置不变</p>
	<p>2. 不能使用额外存储空间</p>
	<p>例子如下</p>
	<p>输入 0, 3, 0, 2, 1, 0, 0</p>
	<p>输出 0, 0, 0, 0, 3, 2, 1</p>
	<h2>分析</h2>
	<p>此排序非传统意义上的排序，因为它要求排序前后非0元素的相对位置不变，或许叫做整理会更恰当一些。我们可以从后向前遍历整个数组，遇到某个位置i上的元素是非0元素时，如果a[k]为0，则将a[i]赋值给a[k]，a[k]赋值为0。实际上i是非0元素的下标，而k是0元素的下标</p>
	<h2>代码</h2>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #0000ff;">void</span><span style="color: #000000;"> Arrange(</span><span style="color: #0000ff;">int</span><span style="color: #000000;">*</span><span style="color: #000000;"> a, </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n)<br>{<br>    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> k </span><span style="color: #000000;">=</span><span style="color: #000000;"> n </span><span style="color: #000000;">-</span><span style="color: #800080;">1</span><span style="color: #000000;"> ;<br>    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #000000;"> n </span><span style="color: #000000;">-</span><span style="color: #800080;">1</span><span style="color: #000000;">; i </span><span style="color: #000000;">&gt;=</span><span style="color: #800080;">0</span><span style="color: #000000;">; </span><span style="color: #000000;">--</span><span style="color: #000000;">i)<br>    {<br>        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (a[i] </span><span style="color: #000000;">!=</span><span style="color: #800080;">0</span><span style="color: #000000;">)<br>        {<br>            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (a[k] </span><span style="color: #000000;">==</span><span style="color: #800080;">0</span><span style="color: #000000;">)<br>            {<br>                a[k] </span><span style="color: #000000;">=</span><span style="color: #000000;"> a[i] ;<br>                a[i] </span><span style="color: #000000;">=</span><span style="color: #800080;">0</span><span style="color: #000000;"> ;<br>            }<br>            </span><span style="color: #000000;">--</span><span style="color: #000000;">k ;<br>        }<br>    }<br>}</span></pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<h1><a name="link18"></a>找出绝对值最小的元素</h1>
	<p>给定一个有序整数序列（非递减序），可能包含负数，找出其中绝对值最小的元素，比如给定序列 -5, -3, -1, 2, 8 则返回1。</p>
	<h2>分析</h2>
	<p>由于给定序列是有序的，而这又是搜索问题，所以首先想到二分搜索法，只不过这个二分法比普通的二分法稍微麻烦点，可以分为下面几种情况</p>
	<ul>
		<li>如果给定的序列中所有的数都是正数，那么数组的第一个元素即是结果。</li>
		<li>如果给定的序列中所有的数都是负数，那么数组的最后一个元素即是结果。</li>
		<li>如果给定的序列中既有正数又有负数，那么绝对值得最小值一定出现在正数和负数的连接处。</li>
	</ul>
	<p>为什么？因为对于负数序列来说，右侧的数字比左侧的数字绝对值小，如上面的-5, -3, -1, 而对于整整数来说，左边的数字绝对值小，比如上面的2, 8，将这个思想用于二分搜索，可先判断中间元素和两侧元素的符号，然后根据符号决定搜索区间，逐步缩小搜索区间，直到只剩下两个元素。</p>
	<h2>代码</h2>
	<p>单独设置一个函数用来判断两个整数的符号是否相同。</p>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #0000ff;">bool</span> SameSign(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
{
    </span><span style="color: #0000ff;">if</span> (a * b &gt; <span style="color: #800080;">0</span><span style="color: #000000;">)
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">else</span>
        <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
}</span></pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<p>主函数代码。</p>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 找出一个非递减序整数序列中绝对值最小的数</span>
<span style="color: #0000ff;">int</span> MinimumAbsoluteValue(<span style="color: #0000ff;">int</span>* a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n)
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Only one number in array</span>
    <span style="color: #0000ff;">if</span> (n ==<span style="color: #800080;">1</span><span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">return</span> a[<span style="color: #800080;">0</span><span style="color: #000000;">] ;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> All numbers in array have the same sign</span>
    <span style="color: #0000ff;">if</span> (SameSign(a[<span style="color: #800080;">0</span>], a[n -<span style="color: #800080;">1</span><span style="color: #000000;">]))
    {
        </span><span style="color: #0000ff;">return</span> a[<span style="color: #800080;">0</span>] &gt;=<span style="color: #800080;">0</span>? a[<span style="color: #800080;">0</span>] : a[n -<span style="color: #800080;">1</span><span style="color: #000000;">] ;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Binary search</span>
    <span style="color: #0000ff;">int</span> l =<span style="color: #800080;">0</span><span style="color: #000000;"> ;
    </span><span style="color: #0000ff;">int</span> r = n -<span style="color: #800080;">1</span><span style="color: #000000;"> ;

    </span><span style="color: #0000ff;">while</span>(l &lt;<span style="color: #000000;"> r)
    {
        </span><span style="color: #0000ff;">if</span> (l +<span style="color: #800080;">1</span>==<span style="color: #000000;"> r)
        {
            </span><span style="color: #0000ff;">return</span> abs(a[l]) &lt; abs(a[r]) ?<span style="color: #000000;"> a[l] : a[r] ;
        }

        </span><span style="color: #0000ff;">int</span> m = (l + r) /<span style="color: #800080;">2</span><span style="color: #000000;"> ;

        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (SameSign(a[m], a[r]))
        {
            r </span>= m -<span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (SameSign(a[l], a[m]))
        {
            l </span>= m +<span style="color: #800080;">1</span><span style="color: #000000;"> ;
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
    }
}</span></pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<p>这段代码是有问题的，感谢网友
		<a id="a_comment_author_2651632" href="http://home.cnblogs.com/u/514263/" target="_blank">lingyunfish</a>的指正，你看出来了么？修改后的代码如下：</p>
	<div class="cnblogs_code">
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
		<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 找出一个非递减序整数序列中绝对值最小的数</span>
<span style="color: #0000ff;">int</span> MinimumAbsoluteValue(<span style="color: #0000ff;">int</span>* a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n)
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Only one number in array</span>
    <span style="color: #0000ff;">if</span> (n ==<span style="color: #800080;">1</span><span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">return</span> a[<span style="color: #800080;">0</span><span style="color: #000000;">] ;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> All numbers in array have the same sign</span>
    <span style="color: #0000ff;">if</span> (SameSign(a[<span style="color: #800080;">0</span>], a[n -<span style="color: #800080;">1</span><span style="color: #000000;">]))
    {
        </span><span style="color: #0000ff;">return</span> a[<span style="color: #800080;">0</span>] &gt;=<span style="color: #800080;">0</span>? a[<span style="color: #800080;">0</span>] : a[n -<span style="color: #800080;">1</span><span style="color: #000000;">] ;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Binary search</span>
    <span style="color: #0000ff;">int</span> l =<span style="color: #800080;">0</span><span style="color: #000000;"> ;
    </span><span style="color: #0000ff;">int</span> r = n -<span style="color: #800080;">1</span><span style="color: #000000;"> ;

    </span><span style="color: #0000ff;">while</span>(l &lt;<span style="color: #000000;"> r)
    {
        </span><span style="color: #0000ff;">if</span> (l + <span style="color: #800080;">1</span> ==<span style="color: #000000;"> r)
        {
            </span><span style="color: #0000ff;">return</span> abs(a[l]) &lt; abs(a[r]) ?<span style="color: #000000;"> a[l] : a[r] ;
        }

        </span><span style="color: #0000ff;">int</span> m = (l + r) /<span style="color: #800080;">2</span><span style="color: #000000;"> ;

        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (SameSign(a[m], a[r]))
        {
            r </span>=<span style="color: #000000;"> m;
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
        else</span><span style="color: #000000;">
        {
            l </span>=<span style="color: #000000;"> m ;
            </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
        }
    }
}</span></pre>
		<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"></a></span></div>
	</div>
	<p>=THE END=</p>
</div>