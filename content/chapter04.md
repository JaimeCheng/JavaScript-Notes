# 4. 变量、作用域和内存问题

## 基本类型值和引用类型值 <a id="value"></a>

* 基本数据类型是按值访问的，引用类型的值是保存在内存中的对象；
* 基本类型值在内存中占据固定大小的空间，被保存在栈内存中，引用类型的值时对象，保存在堆内存中；
* 引用类型的值是保存在内存中的对象，js不允许直接访问内存中的位置，即不能直接操作对象的内存空间，操作对象时，操作的是对象的引用，为对象添加属性时，操作的是实际的对象；
* 只能给引用类型值动态地添加属性，基本类型添加属性不报错但是访问时是 `undefined`；
* 引用类型值的复制实际上引用的是同一个对象（同一个指针），复制的其实是指针，因此两个变量最终都指向同一个对象；
* ECMAScript所有函数的参数是按值传递，理解当参数是对象时仍然是按值传递而不是按引用，但是参数会按引用来访问这个对象；在函数内部重写 `obj` 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁；
* ```js
  function setName(obj) { 
    obj.name = "Nicholas"; 
    obj = new Object(); 
    obj.name = "Greg";
  }
  var person = new Object();
  setName(person);
  alert(person.name);    //"Nicholas"  
  ```

## 检测类型 <a id="test-type"></a>

* 确定一个值是哪种基本类型可以使用 `typeof` 操作符；
* 确定一个值是哪种引用类型可以使用 `instanceof` 操作符\(返回bool\)；
* 引用类型的值都是 `Object` 的实例。因此，`someReferenceVar instanceof Object`，始终会返回 `true`，如果检测基本类型的值，则始终会返回 `false`，因为基本类型不是对象；
* `instanceof` 运算符用来测试一个对象在其原型链（将在第6章学习）中是否存在一个构造函数的 `prototype` 属性；

## 执行环境与作用域 <a id="contexcontext-scope

* JavaScript没有块级作用域；`if` 和 `for {}` 里的变量全局能访问；

12. 为了有效释放内存，应及时接触不再使用的全局对象、全局对象属性以及循环引用变量的引用，如何解除
13. 变量提升（声明变量提升，初始化变量不会提升）、函数提升（声明函数提升，表达式函数不提升），函数声明提升（调用代码在前，声明在后，及时遇到return也会提升）

