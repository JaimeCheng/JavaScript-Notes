# 4. 变量、作用域和内存问题

## 基本类型值和引用类型值  <a id="primitive&reference-
values"></a>

* 基本数据类型是按值访问的，引用类型的值是保存在内存中的对象；
* 基本类型值在内存中占据固定大小的空间，被保存在栈内存中，引用类型的值是对象，保存在堆内存中；
* 值类型赋值时会在内存中开辟一块新的空间，然后把赋过来的值保存于这块新空间中，引用类型赋值时也会开辟一块新的空间，但新空间保存的是赋值对象所在的地址即引用（这就是所谓的浅拷贝）；
* 拓展：**深拷贝和浅拷贝的实现和区别**；
* 引用类型的值是保存在内存中的对象，js不允许直接访问内存中的位置，即不能直接操作对象的内存空间，操作对象时，操作的是对象的引用，为对象添加属性时，操作的是实际的对象；
* 只能给引用类型值动态地添加属性，基本类型添加属性不报错但是访问时是 `undefined`；
* 引用类型值的复制实际上引用的是同一个对象（同一个指针），复制的其实是指针，因此两个变量最终都指向同一个对象；
* ECMAScript所有函数的参数是按值传递，理解当参数是对象时仍然是按值传递而不是按引用，但是参数会按引用来访问这个对象；在函数内部重写 `obj` 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁；
* ```javascript
  function setName(obj) { 
    obj.name = "Nicholas"; 
    obj = new Object(); 
    obj.name = "Greg";
  }
  var person = new Object();
  setName(person);
  alert(person.name);    //"Nicholas"
  ```

## 检测类型  <a id="determining-type"></a>

* 确定一个值是哪种基本类型可以使用 `typeof` 操作符；
* 确定一个值是哪种引用类型可以使用 `instanceof` 操作符\(返回bool\)；
* 引用类型的值都是 `Object` 的实例。因此，`someReferenceVar instanceof Object`，始终会返回 `true`，如果检测基本类型的值，则始终会返回 `false`，因为基本类型不是对象；
* `instanceof` 运算符用来测试一个对象在其原型链（详见第 6 章）中是否存在一个构造函数的 `prototype` 属性；

## 执行环境与作用域  <a id="execution-context-scope"></a>

* JavaScript没有块级作用域；`if` 和 `for {}` 里的变量全局能访问；
* 在 Web 浏览器中，全局执行环境被认为是 `window` 对象\(详见第 7 章\)，因此所有全局变量和函数都是作为 `window` 对象的属性和方法创建的；
* 执行环境有全局执行环境\(也称为全局环境\)和函数执行环境之分；
* 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁\(全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁\)；
* 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境；
* 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
* 变量的执行环境有助于确定应该何时释放内存；
* 延长作用域链：1. `try-catch` 语句的 `catch` 块；2. `with` 语句；
* 作用域链搜索过程，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符；

## 垃圾收集  <a id="garbage-collection"></a>

* JavaScript 是一门具有自动垃圾收集机制的编程语言；
* 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除；
* 标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然

  后再回收其内存；

* 引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法;但在 IE 中访问非原生 JavaScript 对象\(如 `DOM` 元素\)时，这种算法仍然可能会导致问题；
* 当代码中存在循环引用现象时，“引用计数”算法就会导致问题；
* 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处；
* 为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用；
* 将其值设置为 `null` 来释放其引用——这个 做法叫做解除引用\(dereferencing\)。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用；
* 解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收；

## 变量提升  <a id="hoisting"></a>

* 函数及变量的声明都将被提升到函数的最顶部；
* 变量可以先使用再声明，会发生变量提升，（声明变量提升，初始化变量不会提升）；
* 函数可以先调用再声明，会发生函数提升（声明函数提升，表达式函数不提升）；
* ```javascript
  // 声明变量提升
  x = 5;
  var y = x;
  var x;
  console.log(y) // 5

  // 初始化变量不提升
  var b = a;
  var a = 5;
  console.log(b) // undefined

  // 函数提升
  console.log(f1); // function f1() {}   
  console.log(f2); // undefined  
  function f1() {}
  var f2 = function() {}
  ```

